PROBLEMA 1 â€” RICONOSCIMENTO GESTI STATICI (DOCUMENTAZIONE)
=================================================================
Versione: 1.0
Data: 11-08-2025 18:44:03
Autori: Yurii Riina, NicolÃ² Gioacchini, Thomas Marinucci


INDICE
------
1) Obiettivo del problema
2) Panoramica della soluzione (cosa fa, per chi, perchÃ©)
3) Requisiti (MATLAB/toolbox) e file di progetto
4) Come avviare lâ€™app (â€œQuick Startâ€)
5) Architettura e flusso dei dati
6) Interfaccia utente (tab e funzionalitÃ )
7) Algoritmo di estrazione feature
8) Algoritmo di classificazione (rule-based)
9) Input supportati e come testarli
10) Output generati (UI, CSV, sessioni, log)
11) Gestione sessioni, cronologia e log
12) Gestione errori e casi limite
13) Struttura delle cartelle (consigliata/attesa)
14) Mappatura ai requisiti della consegna
15) Estensioni future suggerite
16) Crediti e note finali


1) OBIETTIVO DEL PROBLEMA
-------------------------
Implementare in MATLAB un algoritmo rule-based per il riconoscimento di gesti statici
della mano, come mostrato a lezione. Lâ€™algoritmo deve:
- accettare in input un feature vector (slide 85)
- accettare in input unâ€™immagine (cartella Problema1) da cui ricavare il feature vector
- restituire il risultato della classificazione e mostrarlo allâ€™utente
- essere testato con feature vector diversi
- includere una demo con i nomi dei componenti del gruppo


2) PANORAMICA DELLA SOLUZIONE
-----------------------------
Questa soluzione fornisce:
- Unâ€™APP MATLAB con interfaccia moderna per:
  â€¢ caricare e classificare immagini singole o multiple
  â€¢ inserire/leggere vettori di feature manuali o da .mat
  â€¢ visualizzare risultati, feature estratte, cronologia e log
  â€¢ salvare/caricare sessioni e esportare CSV (stato o batch)
- Una pipeline modulare separata in â€œLogicâ€ e â€œUI helpersâ€
- Un set di utility per robustezza (log, stato sessione, salvataggi, export, etc.)

A chi serve:
- Docenti, valutatori, colleghi e utenti finali che vogliono testare lâ€™algoritmo
  velocemente, vedere i risultati e disporre di tracce (log/CSV) ripetibili.

PerchÃ© cosÃ¬:
- Separazione chiara tra algoritmo, interfaccia e infrastruttura (path, export, sessioni)
  per manutenzione, riuso e facilitÃ  di estensione ai Problemi 2..5.


3) REQUISITI (MATLAB/TOOLBOX) E FILE DI PROGETTO
------------------------------------------------
â€¢ MATLAB R2021a o superiore (consigliato)
â€¢ Image Processing Toolbox (usata per: rgb2gray, imbinarize, bwareaopen, regionprops)
â€¢ Nessuna dipendenza esterna: NON richiede piÃ¹ â€œfindjobjâ€

File principali (nucleo del Problema 1):
- UI:
  â€¢ staticGestureRecognitionUI.m (GUI del modulo)
- Logic:
  â€¢ classifyGestureFromVector.m
  â€¢ classifyGestureFromImage.m
  â€¢ extractFeatures.m
  â€¢ classifyCurrentImage.m, classifyAndLabel.m, classifyAllImages.m
- Sessione/Export/Log:
  â€¢ saveSession.m, loadSession.m, exportHistoryCSV.m, exportSessionCSV.m
  â€¢ addHistoryRowSession.m, writeFullLog.m, logMessage.m, clearHistory.m
  â€¢ enableHistoryTableDoubleClick.m (emulazione doppio click senza Java)
- Utility generiche:
  â€¢ getFileType.m, getFileSize.m, toCsvString.m, safeCell.m, tern.m, aschar.m, toggleFAQEntry.m
- App principale e path:
  â€¢ createApp.m (lanciatore con menÃ¹ e tab generali)
  â€¢ initPaths.m (inizializzazione percorsi)
  â€¢ addFooter.m (footer condiviso â€” firma e logo)


4) COME AVVIARE Lâ€™APP (â€œQUICK STARTâ€)
-------------------------------------
1. Aprire MATLAB nel folder radice del progetto (quello che contiene Main/, Modules/, Data/â€¦).
2. Eseguire createApp:
      >> createApp
   In automatico verranno inizializzati i path (initPaths) e si aprirÃ  la finestra principale.
3. Nella tab â€œğŸ§© Progettiâ€, scegliere â€œProblema 1 â€“ Riconoscimento gesti staticiâ€
   (bottone â€œâ–¶ Visualizza moduloâ€).


5) ARCHITETTURA E FLUSSO DEI DATI
---------------------------------
A. Flusso â€œda immagineâ€
   - loadMultipleImages â†’ aggiorna cronologia/anteprima
   - classifyCurrentImage â†’
       extractFeatures(img) â†’ [c, pr, feat]
       classifyGestureFromVector([c, pr, feat]) â†’ gesto
     Aggiorna UI (tabella feature, label risultato) + cronologia + log

B. Flusso â€œda feature vectorâ€
   - loadFeatureVector (manuale/mat/esistente) â†’ fv
   - classifyGestureFromVector(fv) â†’ gesto
   - Aggiorna tabella/risultato + cronologia + log

C. Batch
   - classifyAllImages â†’ cicla su â€œImageHistoryDataâ€, scrive CSV, aggiorna cronologia & log


6) INTERFACCIA UTENTE (TAB E FUNZIONALITÃ€)
------------------------------------------
TAB 1 â€” Info modulo
  â€¢ Testo descrittivo e obiettivi

TAB 2 â€” Classifica immagine
  â€¢ â€œğŸ“‚ Carica immagineâ€: selezione singola/multipla di file (.png/.jpg/.bmp)
  â€¢ â€œâ–¶ Classifica immagineâ€: applica pipeline allâ€™immagine corrente
  â€¢ â€œğŸ“ Classifica tuttoâ€: applica batch e crea CSV
  â€¢ Pannelli: Anteprima, Risultato (con Log breve), Feature estratte
  â€¢ Tabella â€œFile analizzatiâ€ (cronologia parziale del caricamento)

TAB 3 â€” Vettori di feature
  â€¢ â€œâœ Inserisci manualeâ€: dialog per inserire un vettore numerico
  â€¢ â€œğŸ“ Carica .matâ€: estrae il primo vettore numerico dal file (campo qualunque)
  â€¢ â€œğŸ“ Classifica vettoriâ€: riusa quelli in tabella
  â€¢ Mostra sempre il risultato della classificazione

TAB 4 â€” Sessione (storico + log)
  â€¢ Tabella cronologia completa (Nome, Data, Tipo, Dim KB, Tag, Classe)
  â€¢ Stato operazioni (ultima operazione, stato attivo/inattivo, ultimo export, timestamp)
  â€¢ Pulsanti: â€œğŸ“ Carica sessioneâ€, â€œğŸ’¾ Salva sessioneâ€, â€œğŸ“¤ Esporta CSVâ€, â€œğŸ§¹ Pulisci cronologiaâ€
  â€¢ Log dettagliato (trace di tutte le operazioni)
  â€¢ Doppio click su riga: apertura del file, quando disponibile (emulata via selezioni ravvicinate)


7) ALGORITMO DI ESTRAZIONE FEATURE
----------------------------------
File: extractFeatures.m
Input: path immagine (mano su fondo semplice consigliato)
Passi:
  1) Lettura e conversione in scala di grigi (rgb2gray se necessario)
  2) Segmentazione: imbinarize(Igray, 'adaptive', 'Sensitivity', 0.5)
  3) Pulizia rumore: bwareaopen(bw, round(0.02 * numel(bw)))
  4) Regione principale: regionprops â†’ scelta della regione con Area massima
  5) Calcolo compattezza: c = 4*pi*Area / Perimeter^2
  6) Protrusion Ratio (pr): rapporto orizzontale tra massima estensione a destra e a sinistra
     rispetto al baricentro (Centroid x):
         pr = (maxRight) / (maxLeft)
  7) Altre feature (feat): placeholder (0), estendibile

Dipendenze: Image Processing Toolbox (imbinarize, bwareaopen, regionprops).


8) ALGORITMO DI CLASSIFICAZIONE (RULE-BASED)
--------------------------------------------
File: classifyGestureFromVector.m
Feature attese: fv = [c, pr, otherFeature]
Regole correnti (tarabili):
  - pr > 1.2      â†’ â€œdestraâ€
  - pr < 0.9      â†’ â€œsinistraâ€
  - c < 0.05 e pr in [1.05, 1.20] â†’ â€œstopâ€
  - altrimenti    â†’ â€œriposoâ€

Nota: le soglie sono empiriche e possono/dover essere adattate ai dataset reali.
La funzione Ã¨ stata scritta per essere facilmente estendibile (nuove feature, nuove regole).


9) INPUT SUPPORTATI E COME TESTARLI
-----------------------------------
â€¢ IMMAGINI: png/jpg/bmp. Consigliata mano ben ritagliata e sfondo semplice.
  Test: Tab 2 â†’ â€œğŸ“‚ Carica immagineâ€ â†’ â€œâ–¶ Classifica immagineâ€
  Batch: Tab 2 â†’ â€œğŸ“ Classifica tuttoâ€

â€¢ FEATURE VECTOR: vettore numerico (almeno 2 componenti: [c, pr], la terza Ã¨ opzionale)
  Test: Tab 3 â†’ â€œâœ Inserisci manualeâ€ (es: 0.12 1.05 0) â†’ â€œğŸ“ Classifica vettoriâ€
  MAT: Tab 3 â†’ â€œğŸ“ Carica .matâ€ (primo campo vettoriale numerico trovato)


10) OUTPUT GENERATI (UI, CSV, SESSIONI, LOG)
--------------------------------------------
â€¢ UI:
  - Label â€œRisultato: â€¦â€
  - Tabella â€œFeature estratteâ€ con nomi riga: â€œCompattezzaâ€, â€œProtrusion ratioâ€, feat_1â€¦
  - Anteprima immagine e info (nome, tipo, dimensione)

â€¢ CSV (batch, cronologia):
  - Export batch: Nome file, Compattezza, ProtrusionRatio, AltreFeature, Esito, Data
    (cartella risolta da resolveExportDir; vedi punto 13 â€œStruttura delle cartelleâ€)
  - Export stato sessione (Tab 4): Nome, Data, Tipo, Dim_KB, Tag, Classe

â€¢ Sessioni (.mat):
  Struttura S salvata in saveSession.m, campi principali:
    S.version, S.savedAt
    S.ImageHistoryData, S.CurrentImagePath
    S.HistoryTable, S.HistoryTableFull
    S.FullLog, S.SessionStatusText

â€¢ Log:
  - Log breve (Tab 2, â€œLogBoxâ€): ultimi messaggi in testa
  - Log dettagliato (Tab 4, â€œFullLogBoxâ€): storico completo con timestamp


11) GESTIONE SESSIONI, CRONOLOGIA E LOG
---------------------------------------
â€¢ addHistoryRowSession: aggiunge una riga in Tab 4 ad ogni operazione rilevante
â€¢ saveSession/loadSession: salva/ripristina stato app, tabelle, log, selezioni
â€¢ exportHistoryCSV: esporta lo stato corrente della Tab 4
â€¢ writeFullLog/logMessage: gestiscono log dettagliato e breve, sempre con timestamp
â€¢ clearHistory: resetta tabelle/label/anteprima/appdata, con conferma e log


12) GESTIONE ERRORI E CASI LIMITE
---------------------------------
â€¢ Nessuna immagine caricata â†’ alert e stato â€œwarning/errorâ€
â€¢ File non valido/non leggibile â†’ messaggio dâ€™errore e log
â€¢ Export CSV con cartella non scrivibile â†’ alert e stato â€œerrorâ€
â€¢ Load session con struttura incompleta â†’ ripristino robusto via safeCell
â€¢ Doppio click cronologia: emulato via tempi di selezione; se file mancante â†’ alert


13) STRUTTURA DELLE CARTELLE (CONSIGLIATA/ATTESA)
-------------------------------------------------
Radice progetto/
  â”œâ”€ Main/
  â”‚   â”œâ”€ createApp.m
  â”‚   â”œâ”€ initPaths.m
  â”‚   â”œâ”€ addFooter.m
  â”‚   â””â”€ ModulesUI/
  â”‚       â””â”€ Problem_1_UI/
  â”‚           â”œâ”€ staticGestureRecognitionUI.m
  â”‚           â””â”€ ui_helpers/ (banner.m, pushEffect.m, â€¦)
  â”œâ”€ Modules/
  â”‚   â””â”€ Problem_1/
  â”‚       â”œâ”€ Logic/ (classify*, extractFeatures, â€¦)
  â”‚       â””â”€ Utils/ (log, sessioni, csv, helpers vari)
  â”œâ”€ Data/
  â”‚   â””â”€ Problem_1/
  â”‚       â”œâ”€ sessions/   (sessioni .mat salvate dallâ€™utente)
  â”‚       â””â”€ exports/    (CSV batch/stato)
  â””â”€ Documentation/ (relazione, PDF, immagini, ecc.)

NOTE EXPORT: attualmente la funzione classifyAllImages usa resolveExportDir con logica
storica (cartella di feature_vector_test.mat o di extractFeatures.m, altrimenti pwd).
Per forzare la scrittura in Data/Problem_1/exports, sostituire la risoluzione della cartella
in resolveExportDir con getProjectPaths().p1_exports (se disponibile nel progetto).


14) MAPPATURA AI REQUISITI DELLA CONSEGNA
-----------------------------------------
â€¢ Algoritmo rule-based implementato (classifyGestureFromVector) â†’ OK
â€¢ Input: feature vector (Tab 3) â†’ OK
â€¢ Input: immagine (Tab 2) â†’ OK (con estrazione feature automatica)
â€¢ Test con feature vector diversi â†’ OK (input manuale / .mat)
â€¢ Output mostrato allâ€™utente â†’ OK (label risultato, tabelle, log)
â€¢ Demo con nomi e cognomi â†’ OK (createApp, tab Home/Chi siamo/Progetti)

Extra (oltre i requisiti):
â€¢ Cronologia completa, log dettagliato, export CSV, sessioni salvabili/caricabili,
  doppio click cronologia, gestione batch, stato sessione con colori e timestamp.


15) ESTENSIONI FUTURE SUGGERITE
-------------------------------
â€¢ Migliorare segmentazione (skin detection, sfondo uniforme, morfologia adattiva)
â€¢ Tarare soglie (c_stop, pr_right/pr_left) in base a dataset reali
â€¢ Aggiungere ulteriori feature (solidity, eccentricity, Hu moments, ecc.)
â€¢ Validazione: confusion matrix interna su dataset etichettato
â€¢ Migliorare UX (filtri su cronologia, ricerca, anteprima multipla)
â€¢ Integrazione con Problema 2..5 in createApp (navigazione unificata)


16) CREDITI E NOTE FINALI
-------------------------
â€¢ Sviluppo: Yurii Riina, NicolÃ² Gioacchini, Thomas Marinucci
â€¢ Corso: Approcci e Sistemi di Interfacciamento per i Videogame e la RealtÃ  Virtuale
â€¢ Anno: 2024/2025
â€¢ Dipendenze: Image Processing Toolbox (MATLAB)

Contatti e richiesta supporto:
â€¢ Aprire direttamente lâ€™app (createApp) e usare la sezione â€œGuidaâ€ del modulo
â€¢ Oppure consultare la cartella Documentation/ per la relazione estesa

FINE
